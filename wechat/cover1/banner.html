<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>公众号封面图（竖图转横图）</title>
    <meta name="color-scheme" content="light dark" />
    <link rel="stylesheet" href="../common.css" />
    <style>
      .topbar-inner.tool {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
      }

      .tool-title {
        justify-self: center;
        font-weight: 750;
        letter-spacing: -0.35px;
        font-size: 13px;
        color: var(--text);
      }

      .tool-actions {
        justify-self: end;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .stage-body {
        padding: 14px;
        display: grid;
        gap: 12px;
      }

      .canvas-shell {
        width: min(760px, 100%);
        margin: 0 auto;
      }

      .toolbar {
        padding: 12px;
        border-top: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.05);
      }

      details.advanced {
        border: 1px solid var(--border);
        border-radius: 16px;
        background: rgba(118, 118, 128, 0.05);
        overflow: hidden;
      }

      details.advanced > summary {
        list-style: none;
        cursor: pointer;
        padding: 12px 12px;
        font-weight: 700;
        font-size: 13px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      details.advanced > summary::-webkit-details-marker {
        display: none;
      }

      details.advanced > summary::after {
        content: "展开";
        color: var(--muted);
        font-weight: 650;
        font-size: 12px;
      }

      details.advanced[open] > summary::after {
        content: "收起";
      }

      .advanced-body {
        border-top: 1px solid var(--border);
        padding: 12px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 10px;
      }

      .field {
        grid-column: span 12;
        display: grid;
        gap: 6px;
      }

      select,
      input[type="color"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.10);
        color: var(--text);
        outline: none;
      }
      input[type="color"] {
        padding: 6px;
        height: 42px;
      }

      .seg {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        border: 1px solid var(--border);
        border-radius: 14px;
        overflow: hidden;
      }
      .seg button {
        border: 0;
        padding: 10px 10px;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        font-weight: 650;
        font-size: 12px;
      }
      .seg button[aria-pressed="true"] {
        background: rgba(0, 122, 255, 0.14);
        color: var(--text);
      }

      .status {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }

      @media (min-width: 900px) {
        .toolbar .grid {
          gap: 12px;
        }
        .field.sm-6 {
          grid-column: span 6;
        }
        .field.sm-4 {
          grid-column: span 4;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="topbar-inner tool">
        <a class="brand" href="../../index.html" aria-label="返回首页">
          <span class="brand-mark" aria-hidden="true"></span>
          <span class="brand-title">公众号小工具</span>
        </a>
        <div class="tool-title">竖图转横图</div>
        <div class="tool-actions">
          <button class="btn" id="btnUpload" type="button">上传</button>
          <button class="btn primary" id="btnDownload" type="button" disabled>下载</button>
        </div>
      </div>
    </header>

    <main class="page">
      <section class="stage" aria-label="封面预览">
        <div class="meta-row">
          <div class="k">比例：<strong id="sizeText">2.35:1</strong></div>
          <div class="k muted">拖动调整（Shift 微调）</div>
        </div>
        <div class="stage-body">
          <div
            class="canvas-shell is-empty"
            id="dropZone"
            role="button"
            tabindex="0"
            data-empty-text="点击上传开始（也支持拖拽）"
            aria-label="预览区：点击上传图片，或拖拽图片到这里"
          >
            <canvas id="c" width="900" height="383" aria-label="preview canvas"></canvas>
          </div>
          <div class="status" id="status">上传一张竖图后，可拖动人物调整位置。</div>
        </div>

        <div class="toolbar">
          <input id="file" type="file" accept="image/*" hidden />
          <details class="advanced">
            <summary>更多设置</summary>
            <div class="advanced-body">
              <div class="grid">
                <div class="field sm-6">
                  <label for="format">下载格式</label>
                  <select id="format" aria-label="下载格式">
                    <option value="image/png" selected>PNG</option>
                    <option value="image/jpeg">JPG</option>
                  </select>
                </div>

                <div class="field sm-6">
                  <label for="preset">封面比例</label>
                  <select id="preset">
                    <option value="2.35" selected>2.35:1（消息列表）</option>
                    <option value="1">1:1（转发卡片/主页）</option>
                    <option value="1.7777777778">16:9</option>
                  </select>
                </div>

                <div class="field sm-6">
                  <label>人物位置</label>
                  <div class="seg" role="group" aria-label="subject position">
                    <button type="button" id="posLeft" aria-pressed="false">偏左</button>
                    <button type="button" id="posCenter" aria-pressed="true">居中</button>
                    <button type="button" id="posRight" aria-pressed="false">偏右</button>
                  </div>
                </div>

                <div class="field sm-6">
                  <label>标题可读性（底部压暗）</label>
                  <div class="seg" role="group" aria-label="readability">
                    <button type="button" id="readNormal" aria-pressed="true">自然</button>
                    <button type="button" id="readStrong" aria-pressed="false">加强</button>
                    <button type="button" id="readMax" aria-pressed="false">很强</button>
                  </div>
                </div>

                <div class="field sm-6">
                  <label>背景风格</label>
                  <div class="seg" role="group" aria-label="style">
                    <button type="button" id="styleAuto" aria-pressed="false">自动</button>
                    <button type="button" id="styleSolid" aria-pressed="true">纯色</button>
                    <button type="button" id="styleClear" aria-pressed="false">清爽</button>
                  </div>
                </div>

                <div class="field sm-6" id="bgColorField" style="display: none">
                  <label for="bgColor">背景色</label>
                  <input id="bgColor" type="color" value="#111111" />
                </div>

                <div class="field sm-6">
                  <label>重置</label>
                  <button class="btn" id="btnReset" type="button">重置</button>
                </div>
              </div>
            </div>
          </details>
        </div>
      </section>
    </main>

    <script>
      const els = {
        file: document.getElementById("file"),
        preset: document.getElementById("preset"),
        format: document.getElementById("format"),
        btnReset: document.getElementById("btnReset"),
        btnUpload: document.getElementById("btnUpload"),
        btnDownload: document.getElementById("btnDownload"),
        sizeText: document.getElementById("sizeText"),
        status: document.getElementById("status"),
        canvas: document.getElementById("c"),
        dropZone: document.getElementById("dropZone"),
        bgColorField: document.getElementById("bgColorField"),
        bgColor: document.getElementById("bgColor"),
        // style
        styleAuto: document.getElementById("styleAuto"),
        styleSolid: document.getElementById("styleSolid"),
        styleClear: document.getElementById("styleClear"),
        // readability
        readNormal: document.getElementById("readNormal"),
        readStrong: document.getElementById("readStrong"),
        readMax: document.getElementById("readMax"),
        // position
        posLeft: document.getElementById("posLeft"),
        posCenter: document.getElementById("posCenter"),
        posRight: document.getElementById("posRight"),
      };

      const ctx = els.canvas.getContext("2d", { alpha: false, willReadFrequently: true });

      const state = {
        image: null,
        objectUrl: null,
        outW: 0,
        outH: 0,
        style: "solid", // auto | solid | clear
        readability: "normal", // normal | strong | max
        pos: "center", // left | center | right
        offsetX: 0,
        offsetY: 0,
        subjectRect: null,
        dragging: false,
        justDragged: false,
        dragOffsetX: 0,
        dragOffsetY: 0,
      };

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function setPressed(groupEls, activeEl) {
        for (const el of groupEls) el.setAttribute("aria-pressed", el === activeEl ? "true" : "false");
      }

      function setCanvasSize(width, height) {
        state.outW = width;
        state.outH = height;
        els.canvas.width = width;
        els.canvas.height = height;
        const aspect = Number(els.preset.value) || width / Math.max(1, height);
        const aspectText = aspect.toFixed(2).replace(/\.00$/, "");
        els.sizeText.textContent = `${aspectText}:1`;
      }

      function coverRect(imgW, imgH, dstW, dstH) {
        const scale = Math.max(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function containRect(imgW, imgH, dstW, dstH) {
        const scale = Math.min(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function rgbToHex(r, g, b) {
        const toHex = (n) => n.toString(16).padStart(2, "0");
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      function rgbToHsl(r, g, b) {
        const rr = r / 255;
        const gg = g / 255;
        const bb = b / 255;
        const max = Math.max(rr, gg, bb);
        const min = Math.min(rr, gg, bb);
        const d = max - min;

        let h = 0;
        if (d !== 0) {
          if (max === rr) h = ((gg - bb) / d) % 6;
          else if (max === gg) h = (bb - rr) / d + 2;
          else h = (rr - gg) / d + 4;
          h *= 60;
          if (h < 0) h += 360;
        }

        const l = (max + min) / 2;
        const s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
        return { h, s, l };
      }

      function hslToRgb(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = l - c / 2;
        let rr = 0,
          gg = 0,
          bb = 0;
        if (h >= 0 && h < 60) [rr, gg, bb] = [c, x, 0];
        else if (h >= 60 && h < 120) [rr, gg, bb] = [x, c, 0];
        else if (h >= 120 && h < 180) [rr, gg, bb] = [0, c, x];
        else if (h >= 180 && h < 240) [rr, gg, bb] = [0, x, c];
        else if (h >= 240 && h < 300) [rr, gg, bb] = [x, 0, c];
        else [rr, gg, bb] = [c, 0, x];
        return {
          r: Math.round((rr + m) * 255),
          g: Math.round((gg + m) * 255),
          b: Math.round((bb + m) * 255),
        };
      }

      function pickSolidBgFromImage(img) {
        // Sample a small center-crop to get a stable "overall tone".
        const sampleSize = 48;
        const off = document.createElement("canvas");
        off.width = sampleSize;
        off.height = sampleSize;
        const octx = off.getContext("2d", { willReadFrequently: true });

        const srcW = img.naturalWidth;
        const srcH = img.naturalHeight;
        const crop = Math.min(srcW, srcH);
        const sx = Math.floor((srcW - crop) / 2);
        const sy = Math.floor((srcH - crop) / 2);
        octx.drawImage(img, sx, sy, crop, crop, 0, 0, sampleSize, sampleSize);
        const data = octx.getImageData(0, 0, sampleSize, sampleSize).data;

        let rSum = 0,
          gSum = 0,
          bSum = 0,
          weightSum = 0;
        for (let i = 0; i < data.length; i += 4) {
          const a = data[i + 3] / 255;
          if (a < 0.6) continue;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          // De-emphasize near-white backgrounds (common in证件照边缘).
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const chroma = max - min;
          const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          const w = (0.35 + chroma / 255) * (1 - clamp((luma - 230) / 25, 0, 1));
          rSum += r * w;
          gSum += g * w;
          bSum += b * w;
          weightSum += w;
        }

        if (weightSum <= 1e-6) return "#111111";
        const r = clamp(Math.round(rSum / weightSum), 0, 255);
        const g = clamp(Math.round(gSum / weightSum), 0, 255);
        const b = clamp(Math.round(bSum / weightSum), 0, 255);

        // Convert to a dark, readable solid background while keeping hue.
        const hsl = rgbToHsl(r, g, b);
        const hue = hsl.h;
        const sat = clamp(hsl.s, 0.16, 0.58);
        const light = clamp(0.18 - (hsl.l - 0.5) * 0.06, 0.12, 0.24);
        const rgb = hslToRgb(hue, sat, light);
        return rgbToHex(rgb.r, rgb.g, rgb.b);
      }

      function getBottomLumaEstimate(yStart) {
        const w = els.canvas.width;
        const h = els.canvas.height;
        const y = clamp(Math.floor(yStart), 0, h - 1);
        const hh = clamp(h - y, 1, h);
        const imageData = ctx.getImageData(0, y, w, hh).data;
        const stride = Math.max(4, Math.floor((w * hh) / 42000)) * 4;
        let sum = 0;
        let count = 0;
        for (let i = 0; i < imageData.length; i += stride) {
          const r = imageData[i] / 255;
          const g = imageData[i + 1] / 255;
          const b = imageData[i + 2] / 255;
          sum += 0.2126 * r + 0.7152 * g + 0.0722 * b;
          count += 1;
        }
        return count ? sum / count : 0.5;
      }

      function baseSubjectCenter() {
        const w = els.canvas.width;
        const h = els.canvas.height;
        const x = state.pos === "left" ? w * 0.37 : state.pos === "right" ? w * 0.63 : w * 0.5;
        const y = h * 0.52;
        return { x, y };
      }

      function getReadabilityBase() {
        // Tuned for "文字叠在底部" 的常见封面视觉。
        if (state.readability === "max") return { baseStrength: 0.78, start: 0.5, maxStrength: 0.96 };
        if (state.readability === "strong") return { baseStrength: 0.64, start: 0.53, maxStrength: 0.92 };
        return { baseStrength: 0.5, start: 0.56, maxStrength: 0.88 };
      }

      function render({ applyAutoReadability = true } = {}) {
        const img = state.image;
        const w = els.canvas.width;
        const h = els.canvas.height;
        ctx.save();
        ctx.clearRect(0, 0, w, h);

        if (!img) {
          ctx.fillStyle = "rgba(118,118,128,0.10)";
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = "rgba(110,110,115,0.9)";
          ctx.font = `650 ${Math.round(Math.min(w, h) * 0.06)}px -apple-system, BlinkMacSystemFont, "PingFang SC", sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("上传图片开始", w / 2, h / 2);
          ctx.restore();
          return;
        }

        // Background (Apple-ish: soft, clean).
        if (state.style === "solid") {
          ctx.fillStyle = els.bgColor.value || "#111111";
          ctx.fillRect(0, 0, w, h);
        } else {
          const r = coverRect(img.naturalWidth, img.naturalHeight, w, h);
          const blurPx = state.style === "clear" ? 10 : 18;
          const zoom = state.style === "clear" ? 1.035 : 1.06;
          ctx.save();
          ctx.filter = blurPx > 0 ? `blur(${blurPx}px)` : "none";
          ctx.translate(w / 2, h / 2);
          ctx.scale(zoom, zoom);
          ctx.translate(-w / 2, -h / 2);
          ctx.drawImage(img, r.x, r.y, r.w, r.h);
          ctx.restore();

          // Overall dim: keep "clear" lighter.
          const dim = state.style === "clear" ? 0.06 : 0.14;
          ctx.fillStyle = `rgba(0,0,0,${dim})`;
          ctx.fillRect(0, 0, w, h);
        }

        // Subject (portrait) — auto sizing, minimal knobs.
        const targetH = h * 0.94;
        const subject = containRect(img.naturalWidth, img.naturalHeight, w, targetH);
        const base = baseSubjectCenter();
        const centerX = base.x + state.offsetX;
        const centerY = base.y + state.offsetY;
        const sx = Math.round(centerX - subject.w / 2);
        const sy = Math.round(centerY - subject.h / 2);
        state.subjectRect = { x: sx, y: sy, w: subject.w, h: subject.h, cx: centerX, cy: centerY };

        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.33)";
        ctx.shadowBlur = 18;
        ctx.shadowOffsetY = 7;
        ctx.drawImage(img, sx, sy, subject.w, subject.h);
        ctx.restore();

        // Bottom readability gradient (auto-adjust based on bottom brightness).
        const { baseStrength, start, maxStrength } = getReadabilityBase();
        let strength = baseStrength;
        let startRatio = start;
        let startPx = startRatio * h;
        if (applyAutoReadability) {
          const lumaStart = getBottomLumaEstimate(startPx);
          const lumaDeep = getBottomLumaEstimate(h * 0.78);
          const luma = (lumaStart * 0.55 + lumaDeep * 0.45);
          const target = 0.28;
          const extra = clamp((luma - target) / 0.72, 0, 1);
          // Apple-style: stronger scrim on bright images, and start slightly higher.
          strength = clamp(strength + extra * 0.36 + (luma > 0.72 ? 0.06 : 0), 0, maxStrength);
          startRatio = clamp(startRatio - extra * 0.07, 0.45, 0.66);
          startPx = startRatio * h;
        }
        const g = ctx.createLinearGradient(0, startPx, 0, h);
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, `rgba(0,0,0,${strength})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, startPx, w, h - startPx);

        ctx.restore();
      }

      function updateUI() {
        els.btnDownload.disabled = !state.image;
        els.bgColorField.style.display = state.style === "solid" ? "grid" : "none";
        els.dropZone.classList.toggle("is-empty", !state.image);
        els.dropZone.setAttribute(
          "aria-label",
          state.image ? "预览区：拖动人物调整位置（按住 Shift 微调）" : "预览区：点击上传图片，或拖拽图片到这里"
        );
        els.status.textContent = state.image ? "拖动调整位置，满意后下载。" : "点击上方“上传”，或直接点预览区开始。";
      }

      async function loadImageFromFile(file) {
        if (!file) return;
        if (state.objectUrl) URL.revokeObjectURL(state.objectUrl);
        state.objectUrl = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.src = state.objectUrl;
        await img.decode();
        state.image = img;
        state.offsetX = 0;
        state.offsetY = 0;
        // Default solid background: pick a color that matches the uploaded image tone.
        try {
          els.bgColor.value = pickSolidBgFromImage(img);
        } catch {}
      }

      function applyPreset() {
        const aspect = Number(els.preset.value) || 2.35;
        const wrap = els.dropZone.getBoundingClientRect();
        const cssW = clamp(wrap.width || 360, 300, 720);
        const dpr = window.devicePixelRatio || 1;
        const outW = Math.round(cssW * dpr * 2);
        const outH = Math.round(outW / aspect);
        setCanvasSize(outW, outH);
      }

      function syncAndRender({ applyAutoReadability = true } = {}) {
        applyPreset();
        render({ applyAutoReadability });
        updateUI();
      }

      function download() {
        if (!state.image) return;
        const format = els.format.value;
        const ext = format === "image/jpeg" ? "jpg" : "png";
        const aspect = Number(els.preset.value) || state.outW / Math.max(1, state.outH);
        const aspectText = aspect.toFixed(2).replace(/0+$/, "").replace(/\.$/, "");
        const name = `wechat-cover-${aspectText}-${state.outW}x${state.outH}.${ext}`;
        const url = els.canvas.toDataURL(format, format === "image/jpeg" ? 0.92 : undefined);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function reset() {
        els.preset.value = "2.35";
        els.format.value = "image/png";
        els.bgColor.value = "#111111";
        state.style = "solid";
        state.readability = "normal";
        state.pos = "center";
        state.offsetX = 0;
        state.offsetY = 0;

        setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleSolid);
        setPressed([els.readNormal, els.readStrong, els.readMax], els.readNormal);
        setPressed([els.posLeft, els.posCenter, els.posRight], els.posCenter);

        if (state.objectUrl) URL.revokeObjectURL(state.objectUrl);
        state.objectUrl = null;
        state.image = null;
        els.file.value = "";
        syncAndRender();
      }

      function eventToCanvasPoint(e) {
        const rect = els.canvas.getBoundingClientRect();
        const scaleX = els.canvas.width / rect.width;
        const scaleY = els.canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function hitTestSubject(pt) {
        const r = state.subjectRect;
        if (!r) return false;
        return pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      }

      function onPointerDown(e) {
        if (!state.image) return;
        const pt = eventToCanvasPoint(e);
        if (!hitTestSubject(pt)) return;
        e.preventDefault();
        els.canvas.setPointerCapture(e.pointerId);
        state.dragging = true;
        const base = baseSubjectCenter();
        const centerX = base.x + state.offsetX;
        const centerY = base.y + state.offsetY;
        state.dragOffsetX = pt.x - centerX;
        state.dragOffsetY = pt.y - centerY;
      }

      function onPointerMove(e) {
        if (!state.dragging) return;
        const pt = eventToCanvasPoint(e);
        const fine = e.shiftKey ? 0.35 : 1;
        const base = baseSubjectCenter();
        const nextCenterX = pt.x - state.dragOffsetX;
        const nextCenterY = pt.y - state.dragOffsetY;
        const nextOffsetX = nextCenterX - base.x;
        const nextOffsetY = nextCenterY - base.y;
        state.offsetX = state.offsetX * (1 - fine) + nextOffsetX * fine;
        state.offsetY = state.offsetY * (1 - fine) + nextOffsetY * fine;
        render({ applyAutoReadability: false });
      }

      function onPointerUp(e) {
        if (!state.dragging) return;
        state.dragging = false;
        state.justDragged = true;
        try {
          els.canvas.releasePointerCapture(e.pointerId);
        } catch {}
        render({ applyAutoReadability: true });
      }

      // Events.
      els.file.addEventListener("change", async () => {
        const file = els.file.files && els.file.files[0];
        if (!file) return;
        try {
          await loadImageFromFile(file);
          syncAndRender();
        } catch (err) {
          console.error(err);
          els.status.textContent = "图片加载失败，请换一张试试。";
        }
      });

      els.btnUpload.addEventListener("click", () => els.file.click());

      els.dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
      });
      els.dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        try {
          await loadImageFromFile(file);
          syncAndRender();
        } catch (err) {
          console.error(err);
          els.status.textContent = "图片加载失败，请换一张试试。";
        }
      });

      function openFilePicker() {
        els.file.click();
      }
      els.dropZone.addEventListener("click", (e) => {
        if (state.justDragged) {
          state.justDragged = false;
          return;
        }
        if (state.image) {
          const pt = eventToCanvasPoint(e);
          if (hitTestSubject(pt)) return;
        }
        openFilePicker();
      });
      els.dropZone.addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        openFilePicker();
      });

      els.preset.addEventListener("change", () => {
        state.offsetX = 0;
        state.offsetY = 0;
        syncAndRender({ applyAutoReadability: true });
      });
      els.format.addEventListener("change", () => updateUI());
      els.bgColor.addEventListener("input", () => syncAndRender({ applyAutoReadability: false }));

      els.btnDownload.addEventListener("click", download);
      els.btnReset.addEventListener("click", reset);

      els.canvas.addEventListener("pointerdown", onPointerDown);
      els.canvas.addEventListener("pointermove", onPointerMove);
      els.canvas.addEventListener("pointerup", onPointerUp);
      els.canvas.addEventListener("pointercancel", onPointerUp);
      window.addEventListener("resize", () => syncAndRender({ applyAutoReadability: false }));

      function hookSeg() {
        // Style
        els.styleAuto.addEventListener("click", () => {
          state.style = "auto";
          setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleAuto);
          syncAndRender();
        });
        els.styleSolid.addEventListener("click", () => {
          state.style = "solid";
          setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleSolid);
          if (state.image) {
            try {
              els.bgColor.value = pickSolidBgFromImage(state.image);
            } catch {}
          }
          syncAndRender({ applyAutoReadability: false });
        });
        els.styleClear.addEventListener("click", () => {
          state.style = "clear";
          setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleClear);
          syncAndRender();
        });

        // Readability
        els.readNormal.addEventListener("click", () => {
          state.readability = "normal";
          setPressed([els.readNormal, els.readStrong, els.readMax], els.readNormal);
          syncAndRender();
        });
        els.readStrong.addEventListener("click", () => {
          state.readability = "strong";
          setPressed([els.readNormal, els.readStrong, els.readMax], els.readStrong);
          syncAndRender();
        });
        els.readMax.addEventListener("click", () => {
          state.readability = "max";
          setPressed([els.readNormal, els.readStrong, els.readMax], els.readMax);
          syncAndRender();
        });

        // Position
        els.posLeft.addEventListener("click", () => {
          state.pos = "left";
          state.offsetX = 0;
          state.offsetY = 0;
          setPressed([els.posLeft, els.posCenter, els.posRight], els.posLeft);
          syncAndRender({ applyAutoReadability: false });
        });
        els.posCenter.addEventListener("click", () => {
          state.pos = "center";
          state.offsetX = 0;
          state.offsetY = 0;
          setPressed([els.posLeft, els.posCenter, els.posRight], els.posCenter);
          syncAndRender({ applyAutoReadability: false });
        });
        els.posRight.addEventListener("click", () => {
          state.pos = "right";
          state.offsetX = 0;
          state.offsetY = 0;
          setPressed([els.posLeft, els.posCenter, els.posRight], els.posRight);
          syncAndRender({ applyAutoReadability: false });
        });
      }

      hookSeg();
      reset();
    </script>
  </body>
</html>
