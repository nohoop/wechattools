<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>封面拼图工具</title>
    <meta name="color-scheme" content="light dark" />
    <link rel="stylesheet" href="../common.css" />
    <style>
      .page-head {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 12px;
        margin: 0 0 14px;
      }

      .page-head h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: -0.2px;
      }

      .sub {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .actions .btn {
        border-radius: 999px;
        padding: 10px 14px;
        font-size: 13px;
      }

      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.10);
        color: var(--text);
        outline: none;
        font-weight: 650;
        font-size: 13px;
      }

      .card {
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      @media (prefers-color-scheme: dark) {
        .card {
          background: rgba(22, 22, 24, 0.72);
        }
      }

      .preview {
        padding: 14px;
        display: grid;
        gap: 10px;
      }

      .meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 7px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(118, 118, 128, 0.08);
        font-size: 12px;
        color: var(--muted);
      }

      .pill strong {
        color: var(--text);
        font-weight: 750;
      }

      .canvas-wrap {
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.08);
        width: min(560px, 100%);
        margin: 0 auto;
        position: relative;
        cursor: grab;
      }

      .canvas-wrap.is-empty {
        cursor: pointer;
      }

      .canvas-wrap:active {
        cursor: grabbing;
      }

      .canvas-wrap:focus-visible {
        outline: 3px solid rgba(0, 122, 255, 0.35);
        outline-offset: 3px;
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        touch-action: none;
      }

      .status {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }

      .toolbar {
        padding: 12px;
        border-top: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.05);
      }

      .quick {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
      }

      details.advanced {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: 16px;
        background: rgba(118, 118, 128, 0.05);
        overflow: hidden;
      }

      details.advanced > summary {
        list-style: none;
        cursor: pointer;
        padding: 12px 12px;
        font-weight: 700;
        font-size: 13px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      details.advanced > summary::-webkit-details-marker {
        display: none;
      }

      details.advanced > summary::after {
        content: "展开";
        color: var(--muted);
        font-weight: 650;
        font-size: 12px;
      }

      details.advanced[open] > summary::after {
        content: "收起";
      }

      .advanced-body {
        border-top: 1px solid var(--border);
        padding: 12px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 10px;
      }

      .field {
        grid-column: span 12;
        display: grid;
        gap: 6px;
      }

      @media (min-width: 900px) {
        .field.sm-6 {
          grid-column: span 6;
        }
        .field.sm-4 {
          grid-column: span 4;
        }
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="file"] {
        width: 100%;
      }

      input[type="range"] {
        width: 100%;
      }

      #cropModal {
        position: fixed;
        inset: 0;
        z-index: 999;
        display: none;
        padding: 18px;
      }

      #cropModal[aria-hidden="false"] {
        display: grid;
        place-items: center;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(12px) saturate(150%);
      }

      .modal {
        position: relative;
        width: min(980px, 100%);
        border-radius: 22px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.86);
        box-shadow: 0 30px 90px rgba(0, 0, 0, 0.35);
        overflow: hidden;
      }

      @media (prefers-color-scheme: dark) {
        .modal {
          background: rgba(22, 22, 24, 0.86);
          box-shadow: 0 40px 120px rgba(0, 0, 0, 0.72);
        }
      }

      .modal-head {
        padding: 14px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        border-bottom: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.06);
      }

      .modal-head strong {
        font-weight: 750;
        letter-spacing: -0.2px;
        font-size: 14px;
      }

      .modal-body {
        padding: 14px;
        display: grid;
        gap: 12px;
      }

      .crop-stage {
        border-radius: 18px;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.08);
        overflow: hidden;
        width: min(860px, 92vw);
        margin: 0 auto;
      }

      .crop-stage canvas {
        width: 100%;
        height: auto;
        display: block;
        touch-action: none;
      }

      .modal-actions {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }

      .modal-actions .left {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .modal-actions label {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        margin: 0;
      }

      .seg {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        border: 1px solid var(--border);
        border-radius: 999px;
        overflow: hidden;
        background: rgba(118, 118, 128, 0.06);
      }

      .seg.three {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .seg button {
        border: 0;
        padding: 10px 10px;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        font-weight: 650;
        font-size: 12px;
      }

      .seg button[aria-pressed="true"] {
        background: rgba(0, 122, 255, 0.14);
        color: var(--text);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <a class="nav-back" href="../../index.html">← 首页</a>

      <div class="page-head">
        <div>
          <h1>封面拼图工具</h1>
          <p class="sub">上传两张图 → 点击左右半边调整 → 下载（默认 2.35:1）。</p>
        </div>
        <div class="actions">
          <button class="btn" id="btnUploadLeft" type="button">左图</button>
          <button class="btn" id="btnUploadRight" type="button">右图</button>
          <button class="btn primary" id="btnDownload" type="button" disabled>下载</button>
        </div>
      </div>

      <section class="card" aria-label="拼图画布">
        <div class="preview">
          <div class="meta">
            <div class="pill">比例：<strong id="sizeText">2.35:1</strong></div>
            <div class="pill">导出：<strong id="pxText">—</strong></div>
            <div class="pill">拖动调整位置（按住 Shift 微调）</div>
          </div>

          <div
            class="canvas-wrap is-empty"
            id="dropZone"
            role="button"
            tabindex="0"
            aria-label="预览区：点击上传左右两张图，或拖拽图片到这里"
          >
            <canvas id="c" width="900" height="500" aria-label="preview canvas"></canvas>
          </div>

          <div class="status" id="status">先上传左图和右图（也支持把图片拖拽到画布）。</div>
        </div>

        <div class="toolbar">
          <input id="fileLeft" type="file" accept="image/*" hidden />
          <input id="fileRight" type="file" accept="image/*" hidden />

          <div class="quick">
            <button class="btn" id="btnCrop" type="button">剪裁</button>
            <button class="btn" id="btnReset" type="button">重置</button>
          </div>

          <details class="advanced">
            <summary>更多设置</summary>
            <div class="advanced-body">
              <div class="grid">
                <div class="field sm-6">
                  <label for="format">下载格式</label>
                  <select id="format" aria-label="下载格式">
                    <option value="image/png" selected>PNG</option>
                    <option value="image/jpeg">JPG</option>
                  </select>
                </div>

                <div class="field sm-6">
                  <label for="preset">封面比例</label>
                  <select id="preset">
                    <option value="2.35" selected>2.35:1（消息列表）</option>
                    <option value="1">1:1（转发卡片/主页）</option>
                    <option value="1.7777777778">16:9</option>
                  </select>
                </div>

                <div class="field sm-6">
                  <label>当前调整</label>
                  <div class="seg" role="group" aria-label="active side">
                    <button type="button" id="editLeft" aria-pressed="true">左图</button>
                    <button type="button" id="editRight" aria-pressed="false">右图</button>
                  </div>
                </div>

                <div class="field sm-6">
                  <label>标题可读性（底部压暗）</label>
                  <div class="seg three" role="group" aria-label="readability">
                    <button type="button" id="readNormal" aria-pressed="true">自然</button>
                    <button type="button" id="readStrong" aria-pressed="false">加强</button>
                    <button type="button" id="readMax" aria-pressed="false">很强</button>
                  </div>
                </div>

                <div class="field sm-6">
                  <label for="zoom">缩放</label>
                  <input id="zoom" type="range" min="1" max="6" step="0.01" value="1" />
                </div>

                <div class="field sm-6">
                  <label>当前半边</label>
                  <div class="actions">
                    <button class="btn" id="btnCenter" type="button">居中</button>
                    <button class="btn" id="btnRemove" type="button">移除</button>
                  </div>
                </div>
              </div>
            </div>
          </details>
        </div>
      </section>
    </div>

    <div id="cropModal" aria-hidden="true">
      <div class="modal-backdrop" id="cropBackdrop"></div>
      <div class="modal" role="dialog" aria-modal="true" aria-label="剪裁图片">
        <div class="modal-head">
          <strong>剪裁与缩放</strong>
          <button class="btn" id="cropCancel" type="button">关闭</button>
        </div>
        <div class="modal-body">
          <div class="crop-stage">
            <canvas id="cropCanvas" aria-label="crop canvas"></canvas>
          </div>
          <div class="modal-actions">
            <div class="left">
              <label for="cropZoom">缩放</label>
              <input id="cropZoom" type="range" min="1" max="6" step="0.01" value="1" />
              <span class="pill" style="padding: 6px 10px">提示：拖动图片调整裁切（Shift 微调）</span>
            </div>
            <button class="btn primary" id="cropApply" type="button">应用到封面</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const els = {
        canvas: document.getElementById("c"),
        dropZone: document.getElementById("dropZone"),
        status: document.getElementById("status"),
        sizeText: document.getElementById("sizeText"),
        pxText: document.getElementById("pxText"),
        format: document.getElementById("format"),
        preset: document.getElementById("preset"),
        fileLeft: document.getElementById("fileLeft"),
        fileRight: document.getElementById("fileRight"),
        btnUploadLeft: document.getElementById("btnUploadLeft"),
        btnUploadRight: document.getElementById("btnUploadRight"),
        editLeft: document.getElementById("editLeft"),
        editRight: document.getElementById("editRight"),
        readNormal: document.getElementById("readNormal"),
        readStrong: document.getElementById("readStrong"),
        readMax: document.getElementById("readMax"),
        zoom: document.getElementById("zoom"),
        btnCenter: document.getElementById("btnCenter"),
        btnCrop: document.getElementById("btnCrop"),
        btnRemove: document.getElementById("btnRemove"),
        btnReset: document.getElementById("btnReset"),
        btnDownload: document.getElementById("btnDownload"),
        cropModal: document.getElementById("cropModal"),
        cropBackdrop: document.getElementById("cropBackdrop"),
        cropCanvas: document.getElementById("cropCanvas"),
        cropZoom: document.getElementById("cropZoom"),
        cropCancel: document.getElementById("cropCancel"),
        cropApply: document.getElementById("cropApply"),
      };

      const ctx = els.canvas.getContext("2d", { alpha: false, willReadFrequently: true });
      const cropCtx = els.cropCanvas.getContext("2d", { alpha: false, willReadFrequently: true });

      const state = {
        outW: 0,
        outH: 0,
        active: "left",
        readability: "normal", // normal | strong | max
        dragging: false,
        justDragged: false,
        dragSide: null,
        dragStart: { x: 0, y: 0 },
        left: { img: null, url: null, offsetX: 0, offsetY: 0, zoom: 1 },
        right: { img: null, url: null, offsetX: 0, offsetY: 0, zoom: 1 },
      };

      const cropState = {
        open: false,
        side: "left",
        dragging: false,
        dragStart: { x: 0, y: 0 },
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
      };

      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }

      function setPressed(active) {
        state.active = active;
        els.editLeft.setAttribute("aria-pressed", active === "left" ? "true" : "false");
        els.editRight.setAttribute("aria-pressed", active === "right" ? "true" : "false");
        els.zoom.value = String(state[active].zoom);
      }

      function drawImageCover(targetCtx, img, dstX, dstY, dstW, dstH, zoom, offsetX, offsetY) {
        const base = coverRect(img.naturalWidth, img.naturalHeight, dstW, dstH);
        const z = Math.max(1, zoom || 1);
        const drawW = base.w * z;
        const drawH = base.h * z;
        const x = dstX + (dstW - drawW) / 2 + (offsetX || 0);
        const y = dstY + (dstH - drawH) / 2 + (offsetY || 0);
        targetCtx.drawImage(img, x, y, drawW, drawH);
      }

      function clampSideTransform(side, dstW, dstH) {
        const s = state[side];
        if (!s.img) return;
        s.zoom = Math.max(1, s.zoom || 1);
        const base = coverRect(s.img.naturalWidth, s.img.naturalHeight, dstW, dstH);
        const drawW = base.w * s.zoom;
        const drawH = base.h * s.zoom;
        const maxX = Math.max(0, (drawW - dstW) / 2);
        const maxY = Math.max(0, (drawH - dstH) / 2);
        s.offsetX = clamp(s.offsetX || 0, -maxX, maxX);
        s.offsetY = clamp(s.offsetY || 0, -maxY, maxY);
      }

      function clampCropTransform(dstW, dstH) {
        const img = state[cropState.side].img;
        if (!img) return;
        cropState.zoom = Math.max(1, cropState.zoom || 1);
        const base = coverRect(img.naturalWidth, img.naturalHeight, dstW, dstH);
        const drawW = base.w * cropState.zoom;
        const drawH = base.h * cropState.zoom;
        const maxX = Math.max(0, (drawW - dstW) / 2);
        const maxY = Math.max(0, (drawH - dstH) / 2);
        cropState.offsetX = clamp(cropState.offsetX || 0, -maxX, maxX);
        cropState.offsetY = clamp(cropState.offsetY || 0, -maxY, maxY);
      }

      function isCropOpen() {
        return cropState.open;
      }

      function setCropOpen(nextOpen) {
        cropState.open = nextOpen;
        els.cropModal.setAttribute("aria-hidden", nextOpen ? "false" : "true");
        document.body.style.overflow = nextOpen ? "hidden" : "";
      }

      function cropCanvasDims() {
        const aspect = Number(els.preset.value) || 2.35;
        const sideAspect = aspect / 2;
        const stage = els.cropCanvas.closest(".crop-stage");
        if (stage) stage.style.aspectRatio = `${sideAspect} / 1`;
        const rect = els.cropCanvas.getBoundingClientRect();
        const cssW = clamp(rect.width || 520, 320, 860);
        const dpr = window.devicePixelRatio || 1;
        const outW = Math.round(cssW * dpr * 2);
        const outH = Math.round(outW / sideAspect);
        return { outW, outH };
      }

      function syncCropCanvasSize() {
        const { outW, outH } = cropCanvasDims();
        els.cropCanvas.width = outW;
        els.cropCanvas.height = outH;
      }

      function renderCrop() {
        const img = state[cropState.side].img;
        const w = els.cropCanvas.width;
        const h = els.cropCanvas.height;
        cropCtx.save();
        cropCtx.clearRect(0, 0, w, h);
        cropCtx.fillStyle = "rgba(118,118,128,0.10)";
        cropCtx.fillRect(0, 0, w, h);
        if (img) {
          clampCropTransform(w, h);
          drawImageCover(cropCtx, img, 0, 0, w, h, cropState.zoom, cropState.offsetX, cropState.offsetY);
        }
        cropCtx.restore();
      }

      function openCrop() {
        const side = state.active;
        if (!state[side].img) return;
        cropState.side = side;
        cropState.zoom = state[side].zoom || 1;
        cropState.offsetX = state[side].offsetX || 0;
        cropState.offsetY = state[side].offsetY || 0;
        els.cropZoom.value = String(clamp(cropState.zoom, 1, 6));
        setCropOpen(true);
        syncCropCanvasSize();
        renderCrop();
      }

      function closeCrop() {
        setCropOpen(false);
      }

      function applyCrop() {
        const side = cropState.side;
        state[side].zoom = clamp(Number(cropState.zoom) || 1, 1, 6);
        state[side].offsetX = cropState.offsetX || 0;
        state[side].offsetY = cropState.offsetY || 0;
        if (state.active === side) els.zoom.value = String(state[side].zoom);
        render();
        updateUI();
        closeCrop();
      }

      function setCanvasSize(w, h) {
        state.outW = w;
        state.outH = h;
        els.canvas.width = w;
        els.canvas.height = h;
        const aspect = Number(els.preset.value) || w / Math.max(1, h);
        const aspectText = aspect.toFixed(2).replace(/\.00$/, "");
        els.sizeText.textContent = `${aspectText}:1`;
        els.pxText.textContent = `${w}×${h}`;
      }

      function coverRect(imgW, imgH, dstW, dstH) {
        const scale = Math.max(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function getBottomLumaEstimate(yStart) {
        const w = els.canvas.width;
        const h = els.canvas.height;
        const y = clamp(Math.floor(yStart), 0, h - 1);
        const hh = clamp(h - y, 1, h);
        const imageData = ctx.getImageData(0, y, w, hh).data;
        const stride = Math.max(4, Math.floor((w * hh) / 42000)) * 4;
        let sum = 0;
        let count = 0;
        for (let i = 0; i < imageData.length; i += stride) {
          const r = imageData[i] / 255;
          const g = imageData[i + 1] / 255;
          const b = imageData[i + 2] / 255;
          sum += 0.2126 * r + 0.7152 * g + 0.0722 * b;
          count += 1;
        }
        return count ? sum / count : 0.5;
      }

      function getReadabilityBase() {
        // Tuned for "标题压在封面底部" 的视觉；亮图自动增强。
        if (state.readability === "max") return { baseStrength: 0.78, start: 0.5, maxStrength: 0.96 };
        if (state.readability === "strong") return { baseStrength: 0.64, start: 0.53, maxStrength: 0.92 };
        return { baseStrength: 0.5, start: 0.56, maxStrength: 0.88 };
      }

      function applyPreset() {
        const aspect = Number(els.preset.value) || 2.35;
        const wrap = els.dropZone.getBoundingClientRect();
        const cssW = clamp(wrap.width || 360, 300, 760);
        const dpr = window.devicePixelRatio || 1;
        const outW = Math.round(cssW * dpr * 2);
        const outH = Math.round(outW / aspect);
        setCanvasSize(outW, outH);
      }

      function drawSide(side, x0, w0) {
        const s = state[side];
        const img = s.img;
        const h = els.canvas.height;
        ctx.save();
        ctx.beginPath();
        ctx.rect(x0, 0, w0, h);
        ctx.clip();

        if (!img) {
          ctx.fillStyle = "rgba(118,118,128,0.10)";
          ctx.fillRect(x0, 0, w0, h);
          ctx.restore();
          return;
        }

        clampSideTransform(side, w0, h);
        drawImageCover(ctx, img, x0, 0, w0, h, s.zoom, s.offsetX, s.offsetY);
        ctx.restore();
      }

      function render() {
        applyPreset();
        const w = els.canvas.width;
        const h = els.canvas.height;
        ctx.save();
        ctx.clearRect(0, 0, w, h);

        ctx.fillStyle = "rgba(118,118,128,0.08)";
        ctx.fillRect(0, 0, w, h);

        const half = Math.round(w / 2);
        drawSide("left", 0, half);
        drawSide("right", half, w - half);

        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(half + 0.5, 12);
        ctx.lineTo(half + 0.5, h - 12);
        ctx.stroke();

        // Bottom title-safe scrim (adaptive for bright images).
        const { baseStrength, start, maxStrength } = getReadabilityBase();
        let strength = baseStrength;
        let startRatio = start;
        let startPx = startRatio * h;
        if (state.left.img || state.right.img) {
          const lumaStart = getBottomLumaEstimate(startPx);
          const lumaDeep = getBottomLumaEstimate(h * 0.78);
          const luma = lumaStart * 0.55 + lumaDeep * 0.45;
          const target = 0.28;
          const extra = clamp((luma - target) / 0.72, 0, 1);
          strength = clamp(strength + extra * 0.36 + (luma > 0.72 ? 0.06 : 0), 0, maxStrength);
          startRatio = clamp(startRatio - extra * 0.07, 0.45, 0.66);
          startPx = startRatio * h;
        }
        const g = ctx.createLinearGradient(0, startPx, 0, h);
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, `rgba(0,0,0,${strength})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, startPx, w, h - startPx);

        ctx.restore();
      }

      function updateUI() {
        const ready = !!state.left.img && !!state.right.img;
        els.btnDownload.disabled = !ready;

        const empty = !state.left.img && !state.right.img;
        els.dropZone.classList.toggle("is-empty", empty);
        els.btnUploadLeft.textContent = state.left.img ? "左图 ✓" : "左图";
        els.btnUploadRight.textContent = state.right.img ? "右图 ✓" : "右图";
        els.status.textContent = ready
          ? "点击左/右半边选择，拖动调整；需要更精细可点“剪裁”。"
          : "先上传左图和右图（也支持把图片拖拽到画布）。";
      }

      async function loadImageFromFile(file) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.src = url;
        await img.decode();
        return { img, url };
      }

      async function setSideFile(side, file) {
        if (!file) return;
        const prev = state[side];
        if (prev.url) URL.revokeObjectURL(prev.url);
        const next = await loadImageFromFile(file);
        state[side].img = next.img;
        state[side].url = next.url;
        state[side].offsetX = 0;
        state[side].offsetY = 0;
        state[side].zoom = 1;
        setPressed(state.active);
        render();
        updateUI();
      }

      function download() {
        if (!state.left.img || !state.right.img) return;
        const format = els.format.value;
        const ext = format === "image/jpeg" ? "jpg" : "png";
        const aspect = Number(els.preset.value) || state.outW / Math.max(1, state.outH);
        const aspectText = aspect.toFixed(2).replace(/0+$/, "").replace(/\.$/, "");
        const name = `wechat-stitch-${aspectText}-${state.outW}x${state.outH}.${ext}`;
        const url = els.canvas.toDataURL(format, format === "image/jpeg" ? 0.92 : undefined);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function reset() {
        els.preset.value = "2.35";
        els.format.value = "image/png";
        els.fileLeft.value = "";
        els.fileRight.value = "";
        setReadability("normal");
        for (const side of ["left", "right"]) {
          if (state[side].url) URL.revokeObjectURL(state[side].url);
          state[side].img = null;
          state[side].url = null;
          state[side].offsetX = 0;
          state[side].offsetY = 0;
          state[side].zoom = 1;
        }
        setPressed("left");
        render();
        updateUI();
      }

      function eventToCanvasPoint(e) {
        const rect = els.canvas.getBoundingClientRect();
        const scaleX = els.canvas.width / rect.width;
        const scaleY = els.canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function pickSideByPoint(pt) {
        const half = els.canvas.width / 2;
        return pt.x < half ? "left" : "right";
      }

      function onPointerDown(e) {
        const pt = eventToCanvasPoint(e);
        const side = pickSideByPoint(pt);
        if (!state[side].img) return;
        setPressed(side);
        e.preventDefault();
        els.canvas.setPointerCapture(e.pointerId);
        state.dragging = true;
        state.dragSide = side;
        state.dragStart.x = pt.x;
        state.dragStart.y = pt.y;
      }

      function onPointerMove(e) {
        if (!state.dragging) return;
        const side = state.dragSide;
        if (!side) return;
        const pt = eventToCanvasPoint(e);
        const fine = e.shiftKey ? 0.35 : 1;
        const dx = (pt.x - state.dragStart.x) * fine;
        const dy = (pt.y - state.dragStart.y) * fine;
        state.dragStart.x = pt.x;
        state.dragStart.y = pt.y;
        state[side].offsetX += dx;
        state[side].offsetY += dy;
        const w = els.canvas.width;
        const h = els.canvas.height;
        const half = Math.round(w / 2);
        const sideW = side === "left" ? half : w - half;
        clampSideTransform(side, sideW, h);
        render();
      }

      function onPointerUp(e) {
        if (!state.dragging) return;
        state.dragging = false;
        state.justDragged = true;
        state.dragSide = null;
        try {
          els.canvas.releasePointerCapture(e.pointerId);
        } catch {}
        render();
      }

      // Events
      els.btnUploadLeft.addEventListener("click", () => els.fileLeft.click());
      els.btnUploadRight.addEventListener("click", () => els.fileRight.click());

      els.fileLeft.addEventListener("change", async () => {
        const file = els.fileLeft.files && els.fileLeft.files[0];
        if (!file) return;
        await setSideFile("left", file);
      });
      els.fileRight.addEventListener("change", async () => {
        const file = els.fileRight.files && els.fileRight.files[0];
        if (!file) return;
        await setSideFile("right", file);
      });

      els.editLeft.addEventListener("click", () => setPressed("left"));
      els.editRight.addEventListener("click", () => setPressed("right"));

      function setReadability(mode) {
        state.readability = mode;
        els.readNormal.setAttribute("aria-pressed", mode === "normal" ? "true" : "false");
        els.readStrong.setAttribute("aria-pressed", mode === "strong" ? "true" : "false");
        els.readMax.setAttribute("aria-pressed", mode === "max" ? "true" : "false");
        render();
      }

      els.readNormal.addEventListener("click", () => setReadability("normal"));
      els.readStrong.addEventListener("click", () => setReadability("strong"));
      els.readMax.addEventListener("click", () => setReadability("max"));

      els.zoom.addEventListener("input", () => {
        const v = clamp(Number(els.zoom.value), 1, 6);
        state[state.active].zoom = v;
        const w = els.canvas.width;
        const h = els.canvas.height;
        const half = Math.round(w / 2);
        const sideW = state.active === "left" ? half : w - half;
        clampSideTransform(state.active, sideW, h);
        render();
      });

      els.btnCenter.addEventListener("click", () => {
        state[state.active].offsetX = 0;
        state[state.active].offsetY = 0;
        render();
      });

      els.btnRemove.addEventListener("click", () => {
        const s = state[state.active];
        if (s.url) URL.revokeObjectURL(s.url);
        s.url = null;
        s.img = null;
        s.offsetX = 0;
        s.offsetY = 0;
        s.zoom = 1;
        els.zoom.value = "1";
        render();
        updateUI();
      });

      function eventToCropPoint(e) {
        const rect = els.cropCanvas.getBoundingClientRect();
        const scaleX = els.cropCanvas.width / rect.width;
        const scaleY = els.cropCanvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function onCropPointerDown(e) {
        if (!isCropOpen()) return;
        if (!state[cropState.side].img) return;
        const pt = eventToCropPoint(e);
        e.preventDefault();
        els.cropCanvas.setPointerCapture(e.pointerId);
        cropState.dragging = true;
        cropState.dragStart.x = pt.x;
        cropState.dragStart.y = pt.y;
      }

      function onCropPointerMove(e) {
        if (!cropState.dragging) return;
        const pt = eventToCropPoint(e);
        const fine = e.shiftKey ? 0.35 : 1;
        const dx = (pt.x - cropState.dragStart.x) * fine;
        const dy = (pt.y - cropState.dragStart.y) * fine;
        cropState.dragStart.x = pt.x;
        cropState.dragStart.y = pt.y;
        cropState.offsetX += dx;
        cropState.offsetY += dy;
        renderCrop();
      }

      function onCropPointerUp(e) {
        if (!cropState.dragging) return;
        cropState.dragging = false;
        try {
          els.cropCanvas.releasePointerCapture(e.pointerId);
        } catch {}
        renderCrop();
      }

      els.btnCrop.addEventListener("click", () => openCrop());
      els.cropBackdrop.addEventListener("click", () => closeCrop());
      els.cropCancel.addEventListener("click", () => closeCrop());
      els.cropApply.addEventListener("click", () => applyCrop());
      els.cropZoom.addEventListener("input", () => {
        cropState.zoom = clamp(Number(els.cropZoom.value), 1, 6);
        renderCrop();
      });
      els.cropCanvas.addEventListener("pointerdown", onCropPointerDown);
      els.cropCanvas.addEventListener("pointermove", onCropPointerMove);
      els.cropCanvas.addEventListener("pointerup", onCropPointerUp);
      els.cropCanvas.addEventListener("pointercancel", onCropPointerUp);

      els.preset.addEventListener("change", () => {
        render();
        if (isCropOpen()) {
          syncCropCanvasSize();
          renderCrop();
        }
      });
      els.format.addEventListener("change", () => updateUI());

      els.btnReset.addEventListener("click", (e) => {
        reset();
      });
      els.btnDownload.addEventListener("click", (e) => {
        download();
      });

      els.canvas.addEventListener("pointerdown", onPointerDown);
      els.canvas.addEventListener("pointermove", onPointerMove);
      els.canvas.addEventListener("pointerup", onPointerUp);
      els.canvas.addEventListener("pointercancel", onPointerUp);

      els.dropZone.addEventListener("dragover", (e) => e.preventDefault());
      els.dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        const side = !state.left.img ? "left" : !state.right.img ? "right" : state.active;
        await setSideFile(side, file);
      });

      function openPickerForNext() {
        if (!state.left.img) return els.fileLeft.click();
        if (!state.right.img) return els.fileRight.click();
        return (state.active === "left" ? els.fileLeft : els.fileRight).click();
      }

      els.dropZone.addEventListener("click", (e) => {
        if (state.justDragged) {
          state.justDragged = false;
          return;
        }
        const pt = eventToCanvasPoint(e);
        const side = pickSideByPoint(pt);
        if (!state[side].img) return openPickerForNext();
      });

      els.dropZone.addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        openPickerForNext();
      });

      window.addEventListener("resize", () => render());
      window.addEventListener("resize", () => {
        if (!isCropOpen()) return;
        syncCropCanvasSize();
        renderCrop();
      });
      window.addEventListener("keydown", (e) => {
        if (!isCropOpen()) return;
        if (e.key !== "Escape") return;
        e.preventDefault();
        closeCrop();
      });

      setPressed("left");
      setReadability("normal");
      updateUI();
    </script>
  </body>
</html>
