<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>封面拼图工具</title>
    <meta name="color-scheme" content="light dark" />
    <link rel="stylesheet" href="../common.css" />
    <style>
      .page-head {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 12px;
        margin: 0 0 14px;
      }

      .page-head h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: -0.2px;
      }

      .sub {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.10);
        color: var(--text);
        outline: none;
        font-weight: 650;
        font-size: 13px;
      }

      .card {
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      @media (prefers-color-scheme: dark) {
        .card {
          background: rgba(22, 22, 24, 0.72);
        }
      }

      .preview {
        padding: 14px;
        display: grid;
        gap: 10px;
      }

      .meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 7px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(118, 118, 128, 0.08);
        font-size: 12px;
        color: var(--muted);
      }

      .pill strong {
        color: var(--text);
        font-weight: 750;
      }

      .canvas-wrap {
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.08);
        width: min(420px, 100%);
        margin: 0 auto;
        position: relative;
        cursor: grab;
      }

      .canvas-wrap.is-empty {
        cursor: pointer;
      }

      .canvas-wrap:active {
        cursor: grabbing;
      }

      .canvas-wrap:focus-visible {
        outline: 3px solid rgba(0, 122, 255, 0.35);
        outline-offset: 3px;
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        touch-action: none;
      }

      .status {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }

      .toolbar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        padding: 12px;
        border-top: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.05);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 10px;
      }

      .field {
        grid-column: span 12;
        display: grid;
        gap: 6px;
      }

      @media (min-width: 900px) {
        .field.sm-6 {
          grid-column: span 6;
        }
        .field.sm-4 {
          grid-column: span 4;
        }
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="file"] {
        width: 100%;
      }

      input[type="range"] {
        width: 100%;
      }

      .seg {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        border: 1px solid var(--border);
        border-radius: 999px;
        overflow: hidden;
        background: rgba(118, 118, 128, 0.06);
      }

      .seg button {
        border: 0;
        padding: 10px 10px;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        font-weight: 650;
        font-size: 12px;
      }

      .seg button[aria-pressed="true"] {
        background: rgba(0, 122, 255, 0.14);
        color: var(--text);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <a class="nav-back" href="../../index.html">← 首页</a>

      <div class="page-head">
        <div>
          <h1>封面拼图工具</h1>
          <p class="sub">上传两张图 → 自动填满左右两半 → 拖动微调 → 一键导出。</p>
        </div>
        <div class="actions">
          <select id="format" aria-label="下载格式">
            <option value="image/png" selected>PNG</option>
            <option value="image/jpeg">JPG</option>
          </select>
          <button class="btn" id="btnReset" type="button">重置</button>
          <button class="btn primary" id="btnDownload" type="button" disabled>下载</button>
        </div>
      </div>

      <section class="card" aria-label="拼图画布">
        <div class="preview">
          <div class="meta">
            <div class="pill">尺寸：<strong id="sizeText">900×500</strong></div>
            <div class="pill">拖动调整位置（按住 Shift 微调）</div>
          </div>

          <div
            class="canvas-wrap is-empty"
            id="dropZone"
            role="button"
            tabindex="0"
            aria-label="预览区：点击上传左右两张图，或拖拽图片到这里"
          >
            <canvas id="c" width="900" height="500" aria-label="preview canvas"></canvas>
          </div>

          <div class="status" id="status">先上传左图和右图（也支持把图片拖拽到画布）。</div>
        </div>

        <div class="toolbar">
          <div class="grid">
            <div class="field sm-6">
              <label for="fileLeft">左图</label>
              <input id="fileLeft" type="file" accept="image/*" />
            </div>
            <div class="field sm-6">
              <label for="fileRight">右图</label>
              <input id="fileRight" type="file" accept="image/*" />
            </div>

            <div class="field sm-6">
              <label for="preset">封面尺寸</label>
              <select id="preset">
                <option value="900x500" selected>900×500（推荐）</option>
                <option value="900x383">微信公众号：900×383</option>
                <option value="1000x420">2.38:1：1000×420</option>
              </select>
            </div>

            <div class="field sm-6">
              <label>当前调整</label>
              <div class="seg" role="group" aria-label="active side">
                <button type="button" id="editLeft" aria-pressed="true">左图</button>
                <button type="button" id="editRight" aria-pressed="false">右图</button>
              </div>
            </div>

            <div class="field sm-6">
              <label for="zoom">缩放</label>
              <input id="zoom" type="range" min="0.7" max="1.8" step="0.01" value="1" />
            </div>

            <div class="field sm-6">
              <label>快速操作</label>
              <div class="actions">
                <button class="btn" id="btnCenter" type="button">居中</button>
                <button class="btn" id="btnRemove" type="button">移除当前</button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      const els = {
        canvas: document.getElementById("c"),
        dropZone: document.getElementById("dropZone"),
        status: document.getElementById("status"),
        sizeText: document.getElementById("sizeText"),
        format: document.getElementById("format"),
        preset: document.getElementById("preset"),
        fileLeft: document.getElementById("fileLeft"),
        fileRight: document.getElementById("fileRight"),
        editLeft: document.getElementById("editLeft"),
        editRight: document.getElementById("editRight"),
        zoom: document.getElementById("zoom"),
        btnCenter: document.getElementById("btnCenter"),
        btnRemove: document.getElementById("btnRemove"),
        btnReset: document.getElementById("btnReset"),
        btnDownload: document.getElementById("btnDownload"),
      };

      const ctx = els.canvas.getContext("2d", { alpha: false, willReadFrequently: true });

      const state = {
        outW: 900,
        outH: 500,
        active: "left",
        dragging: false,
        justDragged: false,
        dragSide: null,
        dragStart: { x: 0, y: 0 },
        left: { img: null, url: null, offsetX: 0, offsetY: 0, zoom: 1 },
        right: { img: null, url: null, offsetX: 0, offsetY: 0, zoom: 1 },
      };

      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }

      function setPressed(active) {
        state.active = active;
        els.editLeft.setAttribute("aria-pressed", active === "left" ? "true" : "false");
        els.editRight.setAttribute("aria-pressed", active === "right" ? "true" : "false");
        els.zoom.value = String(state[active].zoom);
      }

      function setCanvasSize(w, h) {
        state.outW = w;
        state.outH = h;
        els.canvas.width = w;
        els.canvas.height = h;
        els.sizeText.textContent = `${w}×${h}`;
      }

      function coverRect(imgW, imgH, dstW, dstH) {
        const scale = Math.max(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function applyPreset() {
        const [w, h] = els.preset.value.split("x").map((v) => Number(v));
        setCanvasSize(w, h);
      }

      function drawSide(side, x0, w0) {
        const s = state[side];
        const img = s.img;
        const h = els.canvas.height;
        ctx.save();
        ctx.beginPath();
        ctx.rect(x0, 0, w0, h);
        ctx.clip();

        if (!img) {
          ctx.fillStyle = "rgba(118,118,128,0.10)";
          ctx.fillRect(x0, 0, w0, h);
          ctx.restore();
          return;
        }

        const base = coverRect(img.naturalWidth, img.naturalHeight, w0, h);
        const cx = x0 + w0 / 2;
        const cy = h / 2;
        ctx.translate(cx, cy);
        ctx.scale(s.zoom, s.zoom);
        ctx.translate(-cx, -cy);
        ctx.drawImage(img, x0 + base.x + s.offsetX, base.y + s.offsetY, base.w, base.h);
        ctx.restore();
      }

      function render() {
        applyPreset();
        const w = els.canvas.width;
        const h = els.canvas.height;
        ctx.save();
        ctx.clearRect(0, 0, w, h);

        ctx.fillStyle = "rgba(118,118,128,0.08)";
        ctx.fillRect(0, 0, w, h);

        const half = Math.round(w / 2);
        drawSide("left", 0, half);
        drawSide("right", half, w - half);

        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(half + 0.5, 12);
        ctx.lineTo(half + 0.5, h - 12);
        ctx.stroke();

        ctx.restore();
      }

      function updateUI() {
        const ready = !!state.left.img && !!state.right.img;
        els.btnDownload.disabled = !ready;

        const empty = !state.left.img && !state.right.img;
        els.dropZone.classList.toggle("is-empty", empty);
        els.status.textContent = ready
          ? "拖动调整位置，满意后点击下载。"
          : "先上传左图和右图（也支持把图片拖拽到画布）。";
      }

      async function loadImageFromFile(file) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.src = url;
        await img.decode();
        return { img, url };
      }

      async function setSideFile(side, file) {
        if (!file) return;
        const prev = state[side];
        if (prev.url) URL.revokeObjectURL(prev.url);
        const next = await loadImageFromFile(file);
        state[side].img = next.img;
        state[side].url = next.url;
        state[side].offsetX = 0;
        state[side].offsetY = 0;
        state[side].zoom = 1;
        setPressed(state.active);
        render();
        updateUI();
      }

      function download() {
        if (!state.left.img || !state.right.img) return;
        const format = els.format.value;
        const ext = format === "image/jpeg" ? "jpg" : "png";
        const name = `wechat-stitch-${state.outW}x${state.outH}.${ext}`;
        const url = els.canvas.toDataURL(format, format === "image/jpeg" ? 0.92 : undefined);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function reset() {
        els.preset.value = "900x500";
        els.format.value = "image/png";
        els.fileLeft.value = "";
        els.fileRight.value = "";
        for (const side of ["left", "right"]) {
          if (state[side].url) URL.revokeObjectURL(state[side].url);
          state[side].img = null;
          state[side].url = null;
          state[side].offsetX = 0;
          state[side].offsetY = 0;
          state[side].zoom = 1;
        }
        setPressed("left");
        render();
        updateUI();
      }

      function eventToCanvasPoint(e) {
        const rect = els.canvas.getBoundingClientRect();
        const scaleX = els.canvas.width / rect.width;
        const scaleY = els.canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function pickSideByPoint(pt) {
        const half = els.canvas.width / 2;
        return pt.x < half ? "left" : "right";
      }

      function onPointerDown(e) {
        const pt = eventToCanvasPoint(e);
        const side = pickSideByPoint(pt);
        if (!state[side].img) return;
        setPressed(side);
        e.preventDefault();
        els.canvas.setPointerCapture(e.pointerId);
        state.dragging = true;
        state.dragSide = side;
        state.dragStart.x = pt.x;
        state.dragStart.y = pt.y;
      }

      function onPointerMove(e) {
        if (!state.dragging) return;
        const side = state.dragSide;
        if (!side) return;
        const pt = eventToCanvasPoint(e);
        const fine = e.shiftKey ? 0.35 : 1;
        const dx = (pt.x - state.dragStart.x) * fine;
        const dy = (pt.y - state.dragStart.y) * fine;
        state.dragStart.x = pt.x;
        state.dragStart.y = pt.y;
        state[side].offsetX += dx;
        state[side].offsetY += dy;
        render();
      }

      function onPointerUp(e) {
        if (!state.dragging) return;
        state.dragging = false;
        state.justDragged = true;
        state.dragSide = null;
        try {
          els.canvas.releasePointerCapture(e.pointerId);
        } catch {}
        render();
      }

      // Events
      els.fileLeft.addEventListener("change", async () => {
        const file = els.fileLeft.files && els.fileLeft.files[0];
        if (!file) return;
        await setSideFile("left", file);
      });
      els.fileRight.addEventListener("change", async () => {
        const file = els.fileRight.files && els.fileRight.files[0];
        if (!file) return;
        await setSideFile("right", file);
      });

      els.editLeft.addEventListener("click", () => setPressed("left"));
      els.editRight.addEventListener("click", () => setPressed("right"));

      els.zoom.addEventListener("input", () => {
        const v = clamp(Number(els.zoom.value), 0.7, 1.8);
        state[state.active].zoom = v;
        render();
      });

      els.btnCenter.addEventListener("click", () => {
        state[state.active].offsetX = 0;
        state[state.active].offsetY = 0;
        render();
      });

      els.btnRemove.addEventListener("click", () => {
        const s = state[state.active];
        if (s.url) URL.revokeObjectURL(s.url);
        s.url = null;
        s.img = null;
        s.offsetX = 0;
        s.offsetY = 0;
        s.zoom = 1;
        els.zoom.value = "1";
        render();
        updateUI();
      });

      els.preset.addEventListener("change", () => render());
      els.format.addEventListener("change", () => updateUI());

      els.btnReset.addEventListener("click", (e) => {
        reset();
      });
      els.btnDownload.addEventListener("click", (e) => {
        download();
      });

      els.canvas.addEventListener("pointerdown", onPointerDown);
      els.canvas.addEventListener("pointermove", onPointerMove);
      els.canvas.addEventListener("pointerup", onPointerUp);
      els.canvas.addEventListener("pointercancel", onPointerUp);

      els.dropZone.addEventListener("dragover", (e) => e.preventDefault());
      els.dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        const side = !state.left.img ? "left" : !state.right.img ? "right" : state.active;
        await setSideFile(side, file);
      });

      function openPickerForNext() {
        if (!state.left.img) return els.fileLeft.click();
        if (!state.right.img) return els.fileRight.click();
        return (state.active === "left" ? els.fileLeft : els.fileRight).click();
      }

      els.dropZone.addEventListener("click", (e) => {
        if (state.justDragged) {
          state.justDragged = false;
          return;
        }
        const pt = eventToCanvasPoint(e);
        const side = pickSideByPoint(pt);
        if (!state[side].img) return openPickerForNext();
      });

      els.dropZone.addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        openPickerForNext();
      });

      window.addEventListener("resize", () => render());

      setPressed("left");
      render();
      updateUI();
    </script>
  </body>
</html>
