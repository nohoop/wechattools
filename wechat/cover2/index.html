<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>封面拼图工具</title>
    <meta name="color-scheme" content="light dark" />
    <link rel="stylesheet" href="../common.css" />
    <style>
      .page-head {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 12px;
        margin: 0 0 14px;
      }

      .page-head h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: -0.2px;
      }

      .sub {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.10);
        color: var(--text);
        outline: none;
        font-weight: 650;
        font-size: 13px;
      }

      .card {
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      @media (prefers-color-scheme: dark) {
        .card {
          background: rgba(22, 22, 24, 0.72);
        }
      }

      .preview {
        padding: 14px;
        display: grid;
        gap: 10px;
      }

      .meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 7px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(118, 118, 128, 0.08);
        font-size: 12px;
        color: var(--muted);
      }

      .pill strong {
        color: var(--text);
        font-weight: 750;
      }

      .canvas-wrap {
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.08);
        width: min(420px, 100%);
        margin: 0 auto;
        position: relative;
        cursor: grab;
      }

      .canvas-wrap.is-empty {
        cursor: pointer;
      }

      .canvas-wrap:active {
        cursor: grabbing;
      }

      .canvas-wrap:focus-visible {
        outline: 3px solid rgba(0, 122, 255, 0.35);
        outline-offset: 3px;
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        touch-action: none;
      }

      .status {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }

      .toolbar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        padding: 12px;
        border-top: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.05);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 10px;
      }

      .field {
        grid-column: span 12;
        display: grid;
        gap: 6px;
      }

      @media (min-width: 900px) {
        .field.sm-6 {
          grid-column: span 6;
        }
        .field.sm-4 {
          grid-column: span 4;
        }
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="file"] {
        width: 100%;
      }

      input[type="range"] {
        width: 100%;
      }

      .seg {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        border: 1px solid var(--border);
        border-radius: 999px;
        overflow: hidden;
        background: rgba(118, 118, 128, 0.06);
      }

      .seg.three {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .seg button {
        border: 0;
        padding: 10px 10px;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        font-weight: 650;
        font-size: 12px;
      }

      .seg button[aria-pressed="true"] {
        background: rgba(0, 122, 255, 0.14);
        color: var(--text);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <a class="nav-back" href="../../index.html">← 首页</a>

      <div class="page-head">
        <div>
          <h1>封面拼图工具</h1>
          <p class="sub">上传两张图 → 自动填满左右两半 → 拖动微调 → 一键导出。</p>
        </div>
        <div class="actions">
          <select id="format" aria-label="下载格式">
            <option value="image/png" selected>PNG</option>
            <option value="image/jpeg">JPG</option>
          </select>
          <button class="btn" id="btnReset" type="button">重置</button>
          <button class="btn primary" id="btnDownload" type="button" disabled>下载</button>
        </div>
      </div>

      <section class="card" aria-label="拼图画布">
        <div class="preview">
          <div class="meta">
            <div class="pill">比例：<strong id="sizeText">2.35:1</strong></div>
            <div class="pill">导出：<strong id="pxText">—</strong></div>
            <div class="pill">拖动调整位置（按住 Shift 微调）</div>
          </div>

          <div
            class="canvas-wrap is-empty"
            id="dropZone"
            role="button"
            tabindex="0"
            aria-label="预览区：点击上传左右两张图，或拖拽图片到这里"
          >
            <canvas id="c" width="900" height="500" aria-label="preview canvas"></canvas>
          </div>

          <div class="status" id="status">先上传左图和右图（也支持把图片拖拽到画布）。</div>
        </div>

        <div class="toolbar">
          <div class="grid">
            <div class="field sm-6">
              <label for="fileLeft">左图</label>
              <input id="fileLeft" type="file" accept="image/*" />
            </div>
            <div class="field sm-6">
              <label for="fileRight">右图</label>
              <input id="fileRight" type="file" accept="image/*" />
            </div>

            <div class="field sm-6">
              <label for="preset">封面比例</label>
              <select id="preset">
                <option value="2.35" selected>微信公众号头条：2.35:1（消息列表）</option>
                <option value="1">1:1（转发卡片/主页）</option>
                <option value="1.7777777778">16:9</option>
              </select>
            </div>

            <div class="field sm-6">
              <label>当前调整</label>
              <div class="seg" role="group" aria-label="active side">
                <button type="button" id="editLeft" aria-pressed="true">左图</button>
                <button type="button" id="editRight" aria-pressed="false">右图</button>
              </div>
            </div>

            <div class="field sm-6">
              <label>标题可读性（底部压暗）</label>
              <div class="seg three" role="group" aria-label="readability">
                <button type="button" id="readNormal" aria-pressed="true">自然</button>
                <button type="button" id="readStrong" aria-pressed="false">加强</button>
                <button type="button" id="readMax" aria-pressed="false">很强</button>
              </div>
            </div>

            <div class="field sm-6">
              <label for="zoom">缩放</label>
              <input id="zoom" type="range" min="0.7" max="1.8" step="0.01" value="1" />
            </div>

            <div class="field sm-6">
              <label>快速操作</label>
              <div class="actions">
                <button class="btn" id="btnCenter" type="button">居中</button>
                <button class="btn" id="btnRemove" type="button">移除当前</button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      const els = {
        canvas: document.getElementById("c"),
        dropZone: document.getElementById("dropZone"),
        status: document.getElementById("status"),
        sizeText: document.getElementById("sizeText"),
        pxText: document.getElementById("pxText"),
        format: document.getElementById("format"),
        preset: document.getElementById("preset"),
        fileLeft: document.getElementById("fileLeft"),
        fileRight: document.getElementById("fileRight"),
        editLeft: document.getElementById("editLeft"),
        editRight: document.getElementById("editRight"),
        readNormal: document.getElementById("readNormal"),
        readStrong: document.getElementById("readStrong"),
        readMax: document.getElementById("readMax"),
        zoom: document.getElementById("zoom"),
        btnCenter: document.getElementById("btnCenter"),
        btnRemove: document.getElementById("btnRemove"),
        btnReset: document.getElementById("btnReset"),
        btnDownload: document.getElementById("btnDownload"),
      };

      const ctx = els.canvas.getContext("2d", { alpha: false, willReadFrequently: true });

      const state = {
        outW: 0,
        outH: 0,
        active: "left",
        readability: "normal", // normal | strong | max
        dragging: false,
        justDragged: false,
        dragSide: null,
        dragStart: { x: 0, y: 0 },
        left: { img: null, url: null, offsetX: 0, offsetY: 0, zoom: 1 },
        right: { img: null, url: null, offsetX: 0, offsetY: 0, zoom: 1 },
      };

      function clamp(v, min, max) {
        return Math.min(max, Math.max(min, v));
      }

      function setPressed(active) {
        state.active = active;
        els.editLeft.setAttribute("aria-pressed", active === "left" ? "true" : "false");
        els.editRight.setAttribute("aria-pressed", active === "right" ? "true" : "false");
        els.zoom.value = String(state[active].zoom);
      }

      function setCanvasSize(w, h) {
        state.outW = w;
        state.outH = h;
        els.canvas.width = w;
        els.canvas.height = h;
        const aspect = Number(els.preset.value) || w / Math.max(1, h);
        const aspectText = aspect.toFixed(2).replace(/\.00$/, "");
        els.sizeText.textContent = `${aspectText}:1`;
        els.pxText.textContent = `${w}×${h}`;
      }

      function coverRect(imgW, imgH, dstW, dstH) {
        const scale = Math.max(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function getBottomLumaEstimate(yStart) {
        const w = els.canvas.width;
        const h = els.canvas.height;
        const y = clamp(Math.floor(yStart), 0, h - 1);
        const hh = clamp(h - y, 1, h);
        const imageData = ctx.getImageData(0, y, w, hh).data;
        const stride = Math.max(4, Math.floor((w * hh) / 42000)) * 4;
        let sum = 0;
        let count = 0;
        for (let i = 0; i < imageData.length; i += stride) {
          const r = imageData[i] / 255;
          const g = imageData[i + 1] / 255;
          const b = imageData[i + 2] / 255;
          sum += 0.2126 * r + 0.7152 * g + 0.0722 * b;
          count += 1;
        }
        return count ? sum / count : 0.5;
      }

      function getReadabilityBase() {
        // Tuned for "标题压在封面底部" 的视觉；亮图自动增强。
        if (state.readability === "max") return { baseStrength: 0.78, start: 0.5, maxStrength: 0.96 };
        if (state.readability === "strong") return { baseStrength: 0.64, start: 0.53, maxStrength: 0.92 };
        return { baseStrength: 0.5, start: 0.56, maxStrength: 0.88 };
      }

      function applyPreset() {
        const aspect = Number(els.preset.value) || 2.35;
        const wrap = els.dropZone.getBoundingClientRect();
        const cssW = clamp(wrap.width || 360, 300, 760);
        const dpr = window.devicePixelRatio || 1;
        const outW = Math.round(cssW * dpr * 2);
        const outH = Math.round(outW / aspect);
        setCanvasSize(outW, outH);
      }

      function drawSide(side, x0, w0) {
        const s = state[side];
        const img = s.img;
        const h = els.canvas.height;
        ctx.save();
        ctx.beginPath();
        ctx.rect(x0, 0, w0, h);
        ctx.clip();

        if (!img) {
          ctx.fillStyle = "rgba(118,118,128,0.10)";
          ctx.fillRect(x0, 0, w0, h);
          ctx.restore();
          return;
        }

        const base = coverRect(img.naturalWidth, img.naturalHeight, w0, h);
        const cx = x0 + w0 / 2;
        const cy = h / 2;
        ctx.translate(cx, cy);
        ctx.scale(s.zoom, s.zoom);
        ctx.translate(-cx, -cy);
        ctx.drawImage(img, x0 + base.x + s.offsetX, base.y + s.offsetY, base.w, base.h);
        ctx.restore();
      }

      function render() {
        applyPreset();
        const w = els.canvas.width;
        const h = els.canvas.height;
        ctx.save();
        ctx.clearRect(0, 0, w, h);

        ctx.fillStyle = "rgba(118,118,128,0.08)";
        ctx.fillRect(0, 0, w, h);

        const half = Math.round(w / 2);
        drawSide("left", 0, half);
        drawSide("right", half, w - half);

        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(half + 0.5, 12);
        ctx.lineTo(half + 0.5, h - 12);
        ctx.stroke();

        // Bottom title-safe scrim (adaptive for bright images).
        const { baseStrength, start, maxStrength } = getReadabilityBase();
        let strength = baseStrength;
        let startRatio = start;
        let startPx = startRatio * h;
        if (state.left.img || state.right.img) {
          const lumaStart = getBottomLumaEstimate(startPx);
          const lumaDeep = getBottomLumaEstimate(h * 0.78);
          const luma = lumaStart * 0.55 + lumaDeep * 0.45;
          const target = 0.28;
          const extra = clamp((luma - target) / 0.72, 0, 1);
          strength = clamp(strength + extra * 0.36 + (luma > 0.72 ? 0.06 : 0), 0, maxStrength);
          startRatio = clamp(startRatio - extra * 0.07, 0.45, 0.66);
          startPx = startRatio * h;
        }
        const g = ctx.createLinearGradient(0, startPx, 0, h);
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, `rgba(0,0,0,${strength})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, startPx, w, h - startPx);

        ctx.restore();
      }

      function updateUI() {
        const ready = !!state.left.img && !!state.right.img;
        els.btnDownload.disabled = !ready;

        const empty = !state.left.img && !state.right.img;
        els.dropZone.classList.toggle("is-empty", empty);
        els.status.textContent = ready
          ? "拖动调整位置，满意后点击下载。"
          : "先上传左图和右图（也支持把图片拖拽到画布）。";
      }

      async function loadImageFromFile(file) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.src = url;
        await img.decode();
        return { img, url };
      }

      async function setSideFile(side, file) {
        if (!file) return;
        const prev = state[side];
        if (prev.url) URL.revokeObjectURL(prev.url);
        const next = await loadImageFromFile(file);
        state[side].img = next.img;
        state[side].url = next.url;
        state[side].offsetX = 0;
        state[side].offsetY = 0;
        state[side].zoom = 1;
        setPressed(state.active);
        render();
        updateUI();
      }

      function download() {
        if (!state.left.img || !state.right.img) return;
        const format = els.format.value;
        const ext = format === "image/jpeg" ? "jpg" : "png";
        const aspect = Number(els.preset.value) || state.outW / Math.max(1, state.outH);
        const aspectText = aspect.toFixed(2).replace(/0+$/, "").replace(/\.$/, "");
        const name = `wechat-stitch-${aspectText}-${state.outW}x${state.outH}.${ext}`;
        const url = els.canvas.toDataURL(format, format === "image/jpeg" ? 0.92 : undefined);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function reset() {
        els.preset.value = "2.35";
        els.format.value = "image/png";
        els.fileLeft.value = "";
        els.fileRight.value = "";
        setReadability("normal");
        for (const side of ["left", "right"]) {
          if (state[side].url) URL.revokeObjectURL(state[side].url);
          state[side].img = null;
          state[side].url = null;
          state[side].offsetX = 0;
          state[side].offsetY = 0;
          state[side].zoom = 1;
        }
        setPressed("left");
        render();
        updateUI();
      }

      function eventToCanvasPoint(e) {
        const rect = els.canvas.getBoundingClientRect();
        const scaleX = els.canvas.width / rect.width;
        const scaleY = els.canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function pickSideByPoint(pt) {
        const half = els.canvas.width / 2;
        return pt.x < half ? "left" : "right";
      }

      function onPointerDown(e) {
        const pt = eventToCanvasPoint(e);
        const side = pickSideByPoint(pt);
        if (!state[side].img) return;
        setPressed(side);
        e.preventDefault();
        els.canvas.setPointerCapture(e.pointerId);
        state.dragging = true;
        state.dragSide = side;
        state.dragStart.x = pt.x;
        state.dragStart.y = pt.y;
      }

      function onPointerMove(e) {
        if (!state.dragging) return;
        const side = state.dragSide;
        if (!side) return;
        const pt = eventToCanvasPoint(e);
        const fine = e.shiftKey ? 0.35 : 1;
        const dx = (pt.x - state.dragStart.x) * fine;
        const dy = (pt.y - state.dragStart.y) * fine;
        state.dragStart.x = pt.x;
        state.dragStart.y = pt.y;
        state[side].offsetX += dx;
        state[side].offsetY += dy;
        render();
      }

      function onPointerUp(e) {
        if (!state.dragging) return;
        state.dragging = false;
        state.justDragged = true;
        state.dragSide = null;
        try {
          els.canvas.releasePointerCapture(e.pointerId);
        } catch {}
        render();
      }

      // Events
      els.fileLeft.addEventListener("change", async () => {
        const file = els.fileLeft.files && els.fileLeft.files[0];
        if (!file) return;
        await setSideFile("left", file);
      });
      els.fileRight.addEventListener("change", async () => {
        const file = els.fileRight.files && els.fileRight.files[0];
        if (!file) return;
        await setSideFile("right", file);
      });

      els.editLeft.addEventListener("click", () => setPressed("left"));
      els.editRight.addEventListener("click", () => setPressed("right"));

      function setReadability(mode) {
        state.readability = mode;
        els.readNormal.setAttribute("aria-pressed", mode === "normal" ? "true" : "false");
        els.readStrong.setAttribute("aria-pressed", mode === "strong" ? "true" : "false");
        els.readMax.setAttribute("aria-pressed", mode === "max" ? "true" : "false");
        render();
      }

      els.readNormal.addEventListener("click", () => setReadability("normal"));
      els.readStrong.addEventListener("click", () => setReadability("strong"));
      els.readMax.addEventListener("click", () => setReadability("max"));

      els.zoom.addEventListener("input", () => {
        const v = clamp(Number(els.zoom.value), 0.7, 1.8);
        state[state.active].zoom = v;
        render();
      });

      els.btnCenter.addEventListener("click", () => {
        state[state.active].offsetX = 0;
        state[state.active].offsetY = 0;
        render();
      });

      els.btnRemove.addEventListener("click", () => {
        const s = state[state.active];
        if (s.url) URL.revokeObjectURL(s.url);
        s.url = null;
        s.img = null;
        s.offsetX = 0;
        s.offsetY = 0;
        s.zoom = 1;
        els.zoom.value = "1";
        render();
        updateUI();
      });

      els.preset.addEventListener("change", () => render());
      els.format.addEventListener("change", () => updateUI());

      els.btnReset.addEventListener("click", (e) => {
        reset();
      });
      els.btnDownload.addEventListener("click", (e) => {
        download();
      });

      els.canvas.addEventListener("pointerdown", onPointerDown);
      els.canvas.addEventListener("pointermove", onPointerMove);
      els.canvas.addEventListener("pointerup", onPointerUp);
      els.canvas.addEventListener("pointercancel", onPointerUp);

      els.dropZone.addEventListener("dragover", (e) => e.preventDefault());
      els.dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        const side = !state.left.img ? "left" : !state.right.img ? "right" : state.active;
        await setSideFile(side, file);
      });

      function openPickerForNext() {
        if (!state.left.img) return els.fileLeft.click();
        if (!state.right.img) return els.fileRight.click();
        return (state.active === "left" ? els.fileLeft : els.fileRight).click();
      }

      els.dropZone.addEventListener("click", (e) => {
        if (state.justDragged) {
          state.justDragged = false;
          return;
        }
        const pt = eventToCanvasPoint(e);
        const side = pickSideByPoint(pt);
        if (!state[side].img) return openPickerForNext();
      });

      els.dropZone.addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        openPickerForNext();
      });

      window.addEventListener("resize", () => render());

      setPressed("left");
      setReadability("normal");
      updateUI();
    </script>
  </body>
</html>
